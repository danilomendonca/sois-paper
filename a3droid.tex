%!TEX root = main.tex
% -*- root: main.tex -*-
\section{A3Droid}
\label{sec:a3droid}

The main contribution of this paper is an entirely new implementation of the A-3 middleware for Android smatphones that targets the development of crowd assisted sensing. 

Our new implementation of A-3 is called \emph{A3Droid} and it is built on top of AllJoyn~\cite{AllJoyn}, an open-source project developed by the Allseen Alliance for interconnecting heteregoneous devices, typically in a smart-living scenario.  

\subsection{A3Droid Nodes}
\label{subg:a3droidNodes}

\begin{figure*}[t!]
\centering
\includegraphics[width=\textwidth]{figures/implementation}
\caption{(a) A3Droid Implementation. (b) A3DroidNode roles.}
\label{fig:implementation}
\end{figure*}

In A3Droid each participant in an application must implement what is called an \texttt{A3DroidNode}. Within the A3DroidNode the developer will specify what groups' existence the node is aware of, and to what extent that node can participate in each group, i.e., if it can participate as a supervisor, as a follower, or as both. 

Since a node can participate in more than one group at a time, in A3Droid we say that it can play multiple \emph{roles}. Technically, a role is a Java class the extends either \texttt{A3DroidAbstractSupervisorRole} or \texttt{A3DroidAbstractFollowerRole}. By extending these classes the developer defines the behaviours that the nodes will need to execute within a specific group. Indeed, the developer must provide one extension of \texttt{A3DroidAbstractSupervisorRole} and/or one extension of \texttt{A3DroidAbstractFollowerRole} for each of groups he wants the node to participate in (see Figure~\ref{fig:implementation}(a)). 

When extending class \texttt{A3DroidAbstractFollowerRole} for a given group, the developer must provide a Java Runnable that implements the following two abstract methods. Method \texttt{run} should contain the node's application-specific follower behaviour for that specific group. \texttt{messageFromSupervisor} should contain the logic that needs to be run when a message is received from the node's supervisor. When extending class \texttt{A3DroidAbstractSupervisorRole} the developer must provide a Java Runnable that implements the following three abstract methods. Method \texttt{run} should contain the node's application-specific supervisor behaviour for that specific group. \texttt{messageFromFollower} should contain the logic that is run when the node receives a message from a follower. \texttt{updateFromGroup} is the logic that should be run every time there is a change in the group's membership. This method is stimulated autonomously by the A3Droid middleware. \texttt{fitnessFunc} represents the application-specific fitness function that is used by A3Droid when it is looking for a new supervisor for the group when performing Supervisor Failure Recovery. Keep in mind that within methods \texttt{run}, \texttt{messageFromFollower}, and \texttt{updateFromGroup} the supervisor can exploit the Topology Control Operations split/merge and stack/unstack discussed in Section~\ref{sub:topologyManagement}. 

Figure~\ref{fig:implementation}(b) illustrates the internal architecture of the A3DroidNode. Each node contains a unique ID, as well as four supporting data structures. \texttt{GroupInfos} keeps track of all the groups that the node is aware of; \texttt{SupervisorRoles} and \texttt{FollowerRoles} keep track of the behaviours that the node is aware of and capable of performing; \texttt{ActiveRoles} keeps track of the actual roles that are being performed at any given time. Each node also contains an \texttt{inNodeSharedMemory} data structure which is used for A-3's \emph{Group State Management}.

\subsection{AllJoyn-based Implementation}
\label{subg:a3droidNodes}

At the center of AllJoyn lies a \emph{virtual bus}, to which devices can connect. The bus distinguished between two kinds of nodes. \emph{Routing nodes} connect directly to the bus, and are responsible for directing messages through the network; \emph{leaf nodes} are nodes that can only connect to routing nodes. As a result, the virtual bus has the structure of a mesh of stars.

To participate in an AllJoyn application one must create a \emph{BusAttachment}, through this attachment publish a \emph{BusObject}, and proceed to ``discover'' the other participants that are connected to the bus. This is achieved through well-known names that are statically provided (e.g., app identifiers). Once the discovery has been completed one can create a \emph{session} and start interacting. A session is either a 1--to--1 or a 1--to--n grouping of devices. An interaction can consist in the invocation of a \emph{BusMethod}, i.e., a 1--to--1 synchronous exchange between two participants; or in the production of a \emph{BusSignal}, i.e., an asynchronous broadcast within the context of the session itself. BusSignals require appropriate \emph{BusListeners} to be registered on the bus.

In A3Droid when a new node wants to connect to a group it uses AllJoyn's discovery mechanism with the group's unique and well-known name. Three things can happen. Frist, if no results are returned, and the node can play the role of the supervisor in that group, the node proceeds to create a special purpose AllJoyn BusObject called the \texttt{Group Manager}. In A3Droid there is always one group manager per group. It is responsible for keeping the group alive by establishing its well-known name on the bus, and for keeping track of group membership. A second BusObject is then created, containing the actual Supervisor Role logic. Second, if no results are returned, and the node cannot play the role of the supervisor, the node gets added to a supporting \emph{wait} group. If this wait group does not exist it is dynamically created, and the node is added as its supervisor. (All A3Droid nodes are capable of being the wait group's supervisor.) Third, if a valid result is returned, and the node can play the role of the group's follower, it is added to the group's ongoing AllJoyn session. To do this it publishes its actual Follower logic onto the bus. 

When the Group Manager and the Supervisor Bus Objects are created they originate on the same physical device. However, this can change over time. The failure of a supervisor does not necessarily imply the failure of the group's Group Manager. In fact, if a supervisor fails but the same is not true for the group manager, when the new supervisor is selected through the leader-election algorithm, the group manager and the new supervisor can effectively come to be on different physical devices. 

When a valid group has been established communication becomes possible. For supervisor--to--follower multicast we use a combination of AllJoyn BusSignals and BusListeners. For supervisor--to--follower unicast communications we use AllJoyn BusMethods, and temporary 1--to--1 sessions are established. In this case the follower needs to publish a \texttt{UnicastReceiver} BusObject onto the bus. Finally, athough follower--to--supervisor unicast messaging could have been implemented in the same way, we decided to use AllJoyn's broadcasting mechanism; the reason for this is that it is inherently more performant than establishing temporary 1--to--1 sessions. To do this each follower is provided with an event emitter, and the supervisor is provided with an appropriate listener.

\begin{figure*}[t!]
\centering
\includegraphics[width=0.8\textwidth]{figures/a3droid}
\caption{A3Droid uses AllJoyn for node communication.}
\label{fig:communication}
\end{figure*}

Figure~\ref{fig:communication} shows an example in which we have a group of three devices called \emph{Group A}. \emph{Device 1} is the first to attempt to connect to group A, and as a result it instantiates both a \emph{Group Manager} BusObject and a \emph{Supervisor} BusObject. \emph{Device 1} and \emph{Device 2} join the group at a later moment. When they do they both instantiate a \emph{Follower} BusObject and connect it to \emph{Session Group A}, which already contains the group's \emph{Group Manager} and the \emph{Supervisor} BusObjects, so that they can start exchanging messages correctly. The two devices also instantiate one \emph{Unicast Receiver} BusObject each, to allow supervisor--to--follower unicast messaging to take place. \emph{Session Device 2} is created for exchanging messages with Device 2.













%target -> 1.75 pages