%!TEX root = main.tex
% -*- root: main.tex -*-
\section{A3Droid}
\label{sec:a3droid}

One of this paper's main contributions is an entirely new implementation of the A-3 middleware for Android smartphones called \emph{A3Droid}. As previously stated, the main focus of our research was to understand how a completely distributed architectural style, such as A-3, could benefit the development of crowdsensing applications on mobile devices. To develop our middleware we decided to exploit AllJoyn~\cite{alljoyn}, an open-source project developed by the Allseen Alliance for interconnecting heterogeneous devices, typically in a smart-living scenario. 

The current status of the AllJoyn project is that it only supports device communication over WiFi; this limitation is therefore also implicitly true for A3Droid. We believe that having to have a WiFi Access Point (AP) on location to enable crowdsensing is not a strong limitation at this point of our work. An access point can easily be added to any scenario: we can create a soft AP using WiFi-Direct~\cite{wifidirect}, we can deploy a traditional low-cost AP, or we can use an Emergency Wireless Routing AP~\cite{EWRAP}. The nature of the deployed AP will, however, have an impact on the number of devices that can be supported by A3Droid. 

As previously stated, A-3 does not exclude other means of communication; it can very well be used in conjunction with an available Internet connection. This way groups can be used to collect data on the field and to manipulate them before re-distributing them to a remote backend server, exploiting a true fog-like architecture.

AllJoyn's current road-map states that there is an interest in providing connectivity over new and upcoming network technologies. Regardless of how the AllJoyn project evolves, in our future work we will investigate how A3Droid can extend its capabilities beyond WiFi. 

\subsection{Application Development}
\label{subg:a3droidNodes}

A3Droid is a framework that Android applications can use to connect to one another and communicate using the abstractions of the A-3 architectural style. The first thing the developer of the Android App needs to do is to implement what we call an \emph{A3DroidNode}. This node defines the behaviors that the Android application will have within the groups it decides to join.

How the application behaves within a specific group is defined by the developer, who must provide an extension of class \texttt{A3SupervisorRole} and/or class \texttt{A3FollowerRole} for that group. If the developer only provides the former, the node will only be able to be a supervisor for that group; if the developer only provides the latter, the node will only be able to be a follower for that group.

%Indeed, the developer must provide one extension of \texttt{SupervisorRole} and/or one extension of \texttt{FollowerRole} for each of groups he wants the node to participate in (see Figure~\ref{fig:implementation}(a)). 

When extending class \texttt{A3FollowerRole}, the developer should provide a Java Runnable that implements the following two abstract methods. Method \texttt{run} should contain the node's application-specific follower behavior for that group. \texttt{messageFromSupervisor} should contain the logic that needs to be run when a message is received from the node's supervisor. When extending class \texttt{A3SupervisorRole} the developer must provide a Java Runnable that implements the following four abstract methods. Method \texttt{run} should contain the node's application-specific supervisor behavior for that group. \texttt{messageFromFollower} should contain the logic that is run when the node receives a message from a follower. \texttt{updateFromGroup} is the logic that should be run every time there is a change in the group's membership. \texttt{fitnessFunc} represents the application-specific fitness function that is used by A3Droid when it is looking for a new group supervisor during Supervisor Failure Recovery. If no fitness function is provided, A3Droid defaults to looking at the devices' battery lives, so that we chose the device with the best chance of lasting longer within the application. Of course within methods \texttt{run}, \texttt{messageFromFollower}, and \texttt{updateFromGroup} the supervisor can exploit the Topology Control Operations split/merge and stack/unstack. 

\begin{figure}[h!]
\centering
\includegraphics[width=\columnwidth]{figures/implementation}
\caption{The internal architectures of three communicating A3DroidNodes.}
\label{fig:implementation}
\end{figure}

Figure~\ref{fig:implementation} illustrates the internal architecture of the A3DroidNode. Each node contains a unique ID, as well as four supporting data structures. \texttt{GroupInfos} keeps track of all the groups that the node is aware of; \texttt{SupervisorRoles} and \texttt{FollowerRoles} keep track of the behaviors that the node is capable of performing; \texttt{ActiveRoles} keeps track of the actual roles that are being performed at any given time. Each node also contains an \texttt{inNodeSharedMemory} data structure which is used for A-3's \emph{Group State Management}.

\subsection{Implementation}
\label{subg:a3droidNodes}

At the center of AllJoyn lies a \emph{virtual bus}, to which devices connect. \emph{Routing nodes} connect directly to the bus, and are responsible for directing messages through the network; \emph{leaf nodes} only connect to routing nodes. As a result, the virtual bus has the structure of a mesh of stars. 

To participate in an AllJoyn application one must i) create a \emph{BusAttachment}, through this attachment ii) publish a \emph{BusObject}, and then iii) proceed to ``discover'' other participants. This is achieved through well-known names that are statically provided (e.g., App identifiers). Once the discovery has been completed one can create a \emph{session} and start interacting. A session is either a 1--to--1 or a 1--to--n grouping of devices. An interaction can consist in the invocation of a \emph{BusMethod}, i.e., a 1--to--1 synchronous exchange between two participants; or in the production of a \emph{BusSignal}, i.e., an asynchronous broadcast within the context of the session itself. BusSignals require appropriate \emph{BusListeners} to be registered on the bus.

In A3Droid when a new node wants to connect to a group it uses AllJoyn's discovery mechanism with the group's unique and well-known name. Three things can happen. First, if no results are returned, and the node can play the role of the supervisor in that group, the node proceeds to create a special purpose AllJoyn BusObject called the \texttt{Group Manager}. In A3Droid there is always one group manager per group. It is responsible for keeping the group alive by establishing its well-known name on the bus, and for keeping track of group membership. A second BusObject is then created, containing the actual Supervisor Role logic. Second, if no results are returned, and the node cannot play the role of the supervisor, the node gets added to a supporting \emph{wait} group. If this wait group does not exist it is dynamically created, and the node is added as its supervisor. (All A3Droid nodes are capable of being the wait group's supervisor.) Third, if a valid result is returned, and the node can play the role of the group's follower, it is added to the group's ongoing AllJoyn session. To do this it publishes its actual Follower logic onto the bus. 

When the Group Manager and the Supervisor Bus Objects are created they originate on the same physical device. However, this can change over time. The failure of a supervisor bus object does not necessarily imply the failure of the group's Group Manager. In fact, if a supervisor bus object fails, but the same is not true for the group manager, when the new supervisor is selected through the leader-election algorithm, the group manager and the new supervisor can effectively be on different physical devices. 

For supervisor--to--follower multicast we use a combination of AllJoyn BusSignals and BusListeners. For supervisor--to--follower unicast communications we use AllJoyn BusMethods, and temporary 1--to--1 AllJoyn sessions. In this case the follower needs to publish a \texttt{UnicastReceiver} BusObject onto the bus. Finally, although follower--to--supervisor unicast messaging could have been implemented in the same way, we decided to use AllJoyn's broadcasting mechanism; the reason for this is that it performs more efficiently than establishing temporary 1--to--1 sessions. To do this each follower is provided with an event emitter, and the supervisor is provided with an appropriate listener.

\begin{figure}[h!]
\centering
\includegraphics[width=0.9\columnwidth]{figures/a3droid}
\caption{A3Droid uses AllJoyn for node communication.}
\label{fig:communication}
\end{figure}


Figure~\ref{fig:communication} shows a group of three devices called \emph{Group A}. \emph{Device 1} is the first to connect; it instantiates both a \emph{Group Manager} BusObject and a \emph{Supervisor} BusObject. \emph{Device 2} and \emph{Device 3} join the group at a later moment. When they do they instantiate a \emph{Follower} BusObject and connect it to \emph{Session Group A}, which already contains the group's \emph{Group Manager} and the \emph{Supervisor} BusObjects. The two devices also instantiate one \emph{Unicast Receiver} BusObject each, to allow supervisor--to--follower unicast messaging to take place. \emph{Session Device 2} is created to allow messaging between the supervisor and Device 2.













%target -> 1.75 pages