The organization model based on groups and roles provides a highly flexible way of modularizing application logic. Roles are components with clear responsibilities that can be shared among devices. Reasons for distributing roles are many. First and foremost, the same role can be replicated to improve the availability, performance, and other quality attributes. The scale of the replication may be limited by the availability of devices only (e.g., as many replicas as possible), or it may be specified by the application (different cardinalities for different roles). Moreover, due to heterogeneity, some devices may lack certain capabilities, while others have additional capabilities. This impairment may be temporal - due to context changes - or it can be permanent - due to hardware or software limitations. Accordingly, certain roles can be designed to allow specific functionalities to be distributed to capable devices. This flexibility can be explored to allow the system to adapt to dynamic and heterogeneous environments. Figure~\ref{fig:roles_distribution} illustrates a set of devices playing both replicated and distinct roles.

In a mobile and volatile environment, it is hard for peer devices to keep track of one another, and consequently to interact, without proper abstractions. Some of the common problems include discovering, advertisement, communication, and state management. These operational problems translate into complexness of the system design. A group based organization provides an abstraction that can be used to guide and structure the virtual environment where distributed components can interact and cooperate. While nodes are expected to come and go from the application with a high frequency, groups can outlive components, provide well known mechanisms for communication and coordination, and to allow the partitioning of the system according to different types of criteria. For instance, groups may reflect the partitions in the physical world, such as the physical space or time where/when components should operate, or the availability of physical resources, such as the battery level and the availability of sensors; it can also reflect logical criteria, such as access privileges and other policies, or the model and operational system version of devices; finally, it can reflect any criteria from the application itself.%, including functional and non-functional requirements which may or may not relate to the physical world.

To shape the (desired) composition of a group, \textit{membership criteria} can be used to define the allowed configurations for roles within groups. In our proposal, these criteria can specify which roles (class) can be part of a group, and how many roles of each type can be in the group at the same time (cardinality). In addition, other customized criteria can be specified either statically, at design-time, or programmatically, at runtime. Accordingly, a group can have different degrees of flexibility, ranging from a static group whose membership criteria is fixed to a dynamic group whose membership criteria is updated at runtime.

\begin{figure*}[t!]
	\centering
	\includegraphics[width=0.8\textwidth]{figures/organization_meta_model}
	\caption{The GRD organization meta-model. Each device in the organization may play different roles in different groups (active roles). Also, roles are specialized into application and adaptation roles.}
	\label{fig:organization_meta_model}
\end{figure*}

\subsection{Groups Life Cycle}

There are four phases of a group life-cycle: formation, operation, and reorganization. The diagram in figure~\ref{fig:group_phases} represent these phases.

\begin{figure}[t!]
\centering
\includegraphics[width=0.85\linewidth]{figures/group_phases}
\caption{The phases of a group lifecycle.}
\label{fig:group_phases}
\end{figure}

\subsubsection{Group Formation}

Initially, groups are created following the \textbf{create} command, which is issued by the application. For instance, this command may follow an internal application event or some external event captured by some system node. A group remains idle until its activation criteria is met. 

Once a group has been created, there are two possible ways of composing its membership: following a \textbf{join} command issued by the application node, or through self-grouping mechanisms provided by our proposed middleware. These are very different use cases. In the first, the application has the prerogative to , group membership criteria is used.

The \textbf{join} command allows application nodes to define their intention to join a given group using a well known group name. The conditions for accomplishing the membership are the following. Firstly, the node must specify which roles it intends to play in the group. Secondly, the group membership criteria must include one or more of these roles. Third, the accession of that node must not violate the group membership criteria for cardinality of roles. 

\subsubsection{Group Adaptation}

Once groups are formed, i.e., once they met their activation criteria, they become active. As a consequence of context changes, groups may have to reorganize their formation. Unless a group downgrades to a drastic state in which its activation criteria is violated, it should remain active while self-organization mechanisms take place. 

In our work, a middleware is responsible for many features, including parsing the group activation criteria declared by the application, monitoring the environment for the availability of components, and activating the group once its activation criteria has been met. Also, two types of criteria are supported by the middleware. The first consists of a raw specification of which roles should be part of a group. This criteria type have multiple purposes: it can define what roles \textit{can} join a group, what roles \textit{must} join a group, as well as \textit{how many} of each role can/must join a group.  In addition, the application may also specify which roles a node can play~\footnote{from now on the term node and device will be used interchangeably}. Based on both group activation criteria, the nodes participation criteria, the middleware must select which nodes will play which roles in the to-be-activated group. Finally, once the criteria is met, the group is activated.

Regarding the distribution of roles, we envision two scenarios. In a starvation scenario, there are more vacant positions for roles than available devices to play them, or just as much as required by the existing groups activation criteria. Thus, a maximum allocation of roles strategy is used. In an opposite scenario, there are more devices able to play the required roles than what is specified by current criteria. The role allocation problem takes place at two phases: when groups are been formed, and when their formation is been adapted. IMPORTANCE OF A GOOD ALLOCATION

For example, (IF POSSIBLE, DESCRIBE THE GROUPS OF SOME APPLICATION EXAMPLE HERE).

A second and more sophisticated type of group criteria encompasses the non-functional requirements that must be met by a group. 

For example, groups may reflect functional capabilities of components or present certain quality attributes. Also, groups may be constituted components according to physical attributes of the operational hosts (devices), like the physical location. The partitioning may also represent a logical division within the application, like a mobile multi-player game session. Following the separation of concerns principle, groups can also cover different aspects of the application. Figure~\ref{fig:organization_meta_model} presents the GRD meta-model.


\section{Groups Self-organization}
\label{sec:self_organization}

\section{The Middleware}
\label{sec:middleware}

The design of a GRD based application starts with the specification of the groups and their criteria for activation. Groups are described by a list of application roles that can or must join the group. For each type of role, the membership type and its multiplicity are both specified with [0-*], a standard UML notation for expressing association multiplicity. In our model, 0 should be read as optional membership, meaning the group may become active without that role; positive integers define the multiplicities for non-optional membership of roles required for the group activation; the * symbol specifies unlimited multiplicity of a given role; finally, the - symbol specifies a membership type/multiplicity range.

Once the different groups and their activation criteria have been defined, the different application roles must be implemented. Active roles can communicate with each other through standard group communication methods, namely unicast, multicast, and broadcast. Each active role has an unique identifier (RID) within the group, which is used for unicast messages. Multicast messages can address either the RID of multiple active roles or all the active roles of a given type. Finally, broadcast messages address all active roles.

The GRD model does not impose restrictions on how coordination and other application tasks should be distributed. For instance, a given application may define a specific role responsible for coordinating other role's activities, while the other role(s) could implement just a thin part of the application logic. Or, roles may choreograph their activities using peer-to-peer communication. Moreover, an hybrid approach may combine different styles for different groups and/or roles. A good distribution of the computational load should avoid unbalanced use of devices' resources, while a more centralized intragroup coordination may be simpler to design and require less message exchanges.


%As a result of the join command, the application is notified about the success or failure in joining the group. A total success is returned if the node joins the group with all desired roles.