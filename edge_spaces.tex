\section{Self-organizing Edge Spaces}\label{sec:edge_spaces}

%I'm mixing the explanation of what is a 
\subsection{Discovery}

The realization of an interaction space poses many technical challenges. First, the application nodes sharing the same network must be able to perceive each other (discovery). Popular platforms such as Android and iOS provide native mechanisms that allow nodes to advertise and discover their services and resources~\cite{ANDROID_NSD, IOS_Bonjour}. Additionally, third party frameworks also provide discovery, messaging and other features based on different paradigms and communication protocols~\cite{Alljoyn, IoTivity}. 

FIGURE: MOBILE DEVICES NOT/RUNNING A GIVEN APPLICATION INTERCONNECTED THROUGH WI-FI

%TALK ABOUT THE DCVRY METHODS AND THEIR SUITABILITY TO THE SCENARIO AND REQUIREMENTS PRESENTED BY THIS WORK.

Whereas previous coordinating models for mobile computing assumed the worse case for connectivity (nodes eventually meet and exchange data)~\cite{LIME, TUCSON, OTHERS}, nowadays wireless technologies makes it possible for multiple application nodes to be interconnected at the same time. Given the resource limitations of mobile devices, discovery mechanisms shall be efficient and avoid creating too much computational overhead or flood the network with discovery messages. As the peer scale grows, such requirements becomes critic for the feasibility of an edge space for interactive applications. 

%TODO provide details about IoTivity

\subsection{Asymmetry}

In addition to the problems of discovery and communication, the dynamic allocation of tasks to different application nodes is a central feature that further distinguishes this work from previous frameworks~\cite{}. Similarly to well studied allocation of tasks to agents/robots with dynamic and distinct capabilities~\cite{}, mobile devices are heterogeneous and subject to hight volatility, therefore their fitness in performing different tasks varies from one device to the other and throughout time. Asymmetric roles is more evident when mobile application instances become more than just clients of remote servers. For example, in opportunistic mobile crowdsensing, data must be fetched from devices sensors without user participation and application nodes may autonomously collaborate by aggregating fetched data from multiple devices into a single device, which in turn sends the aggregated data to the server~\cite{}. Thus, one-out-of-many nodes must assume the role of an aggregator. Moreover, if the number of application nodes at a given moment is high, not every node should perform the same sensing tasks. Instead, a subset of application nodes can be assigned to a given sensing task, reducing the overall battery and mobile data consumption. 

FIGURE: CIRCLE WITH HALF SYMMETRIC HALF ASYMMETRIC BEHAVIOR

\subsection{Organization Model}

Despite the many possible types of asymmetric tasks, in this paper we focus on those whose importance for the application and cost for the devices are significant, i.e., the computation and communication overhead for its allocating is justified. Accordingly, we adopt the organization concept of a \textit{role} to refer to application behaviors (generally asymmetric) that fulfills one or more application requirements. This concept has been used by organization centered multi-agent systems~\cite{}, for which organizations are frameworks where agents with different capabilities may interact. Such abstraction brings forward the social aspect of applications whose components should behave and interact based on the role they are assigned to in the organization they belong to, going beyond the static client-server roles of today's mainstream model for mobile applications. Figures~\ref{fig:client-server} and~\ref{fig:crowdsensing} illustrate the difference between these models.

FIGURE: a) CLIENTS + SERVER; b) INTERACTING ROLES + SERVER

In addition to the role abstraction, the organization formed by application nodes may also be partitioned into groups. The advantage of partitioning the interaction space into groups is to have a well defined scope in which roles can interact. Whereas this can be achieved using communication and coordination methods that limit the audience of messages -- for instance, publish/subscribe mechanisms in which events are only captured by registered listeners -- making partitions explicit through groups complement the organizational view of the system provided by the role abstraction. Together, groups and roles form the building blocks of the organization structure of the application. The volatility imposed by the mobility and resource constraints of hosts requires the \textit{self-management} of this organization structure.

FIGURE: GROUPS

\subsection{Distributed Role Allocation}
 
The decision of which node(s) should be assigned to which roles(s) may depend on many factors. Trivially, any node capable of performing a role is a potential candidate. Notwithstanding this, there are attributes affected by this choice, such as the quality of the data fetched by different devices in a given context or the availability of resources like battery and allocation fairness. A balanced role allocation must respect the trade off between what is best for the application goals and the devices owners. The later is specially important in volunteer based applications such as mobile crowdsensing, as efficient and fair use of devices resources works as an incentive for participation. 

We use Gerkey and Matarić’s taxonomy~\cite{} to present a categorization of the role allocation problem along three axes. In the first axis, nodes are categorized into two types: single-role versus multi-role nodes\footnote{Originally, the taxonomy refers to \textit{robots} and \textit{tasks}, while in this paper we refer to the (application) \textit{nodes} and the \textit{roles} they can perform.}. As application nodes are generally capable of performing more than one role at a time -- for instance, to fetch from multiple sensors -- nodes are considered as multi-role. In the second axis, roles are categorized into two types: single-node vs multi-node roles. While certain types of role are performed by a single node -- for instance, the aggregator of sensor data -- there are cases in which a role must be performed by multiple nodes. Thus, node cardinality depends on the role. Finally, in the third axis, the allocation is also categorized into two types: instantaneous assignment or time-extended assignment. Due to the volatility of mobile devices (churn and capability changes), the scheduling of future allocations tends to fail. Accordingly, we consider an instantaneous assignment of roles based on the current context of the involved devices.

FIGURE: META MODEL FOR NODE-ROLE

In the literature, many works have proposed methods for the distributed allocation of tasks. As the we consider a scenario in which application nodes hosted by volatile and resource constrained devices must self-organize their activities, the allocation method shall satisfy the following requirements:

\begin{itemize}
	
	\item Distributed: allocation decision should not be centralized by one device in order to avoid bottlenecks;
	
	\item Communication overhead: only essential data should be exchanged in order to avoid communication costs; 
	
	\item Privacy: sensitive information shall not be disclosed;
	
	\item Coherence: the allocation method performance/cost should be tuned according to the role constraints and criticality.
	  
\end{itemize} 

Marked based methods have been extensively studied.

%For example, one-out-of-many device may be a better candidate to host the coordinator of the activities performed by a group of application nodes or to use specific sensors to extract information from the physical environment. Whenever asymmetry characterizes a behavior, i.e., not every node must perform it, and the performance, the cost, or other attributes of such behavior are to be considered, the decision of which node to perform it should take the context of the hosting devices into account. In this work, we considered asymmetric tasks whose importance for the system justifies the overhead for their allocation. %We compare our approach with straightforward solutions to demonstrate the feasibility and benefits of a context-dependent allocation. 

%In specific, we focus on the \textit{efficiency, robustness, and fairness} resulting from an appropriate distribution of system responsibilities to local devices taking into account the dynamicity of their resources and capabilities, as well as their history of participation (fairness). To achieve a scalable solution for these problems, we propose a two-level mechanism for the partitioning of the edge space into subset of devices (groups) and the classification of these subsets by their fitness to play different system roles (assignment). 



%the partitioning of the edge space according to different criteria and

 %In special, we are concerned with system functionalities that can assigned to one or more devices within the edge space. 
%The main novelties here are:
%
%\begin{itemize}
%
%\item Pervasive and mobile devices are seen as volatile and heterogeneous computational platforms with resource limitations.
%
%\item Distinct responsibilities may be assigned to a subset of the mobile devices running the same application.
%
%\end{itemize}


%First, we show how our framework can enable ad hoc interactions without external storage and control provided by cloud infrastructure. Second, we present a mobile multi-player game scenario in which low latency communication is the main requirement. Finally, we describe a mobile crowdsensing application, which combines different requirements, including efficient use of battery and mobile data plan. 



%which here are hampered by volatility, 
%
%\begin{itemize}
%
%\item Discovery: devices must be able to recognize each other in the space
%
%\item Transparency: devices must be able to communicate without previous knowledge of their network address
%
%\item Dynamic allocation: devices must be able to agree on the role they will play in the system 
%
%\item Partitioning: devices must be able to further partition the interaction space 
%
%\end{itemize}

