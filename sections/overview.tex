%This section provides the overview over the main concepts of the paper, as well as a general comparison with existing work. The detailed comparison with other proposals is found in the Related Work Section.
\section{Overview}\label{sec:overview}

%This subsection contextualizes the reader w.r.t. existing fields in which OI take place and explains why they fail to address the specific requirements for engineering PA.
\subsection{Local and Opportunistic Interactions}

Opportunistic interactions among devices through wireless networks have been addressed by different research areas. Distributed artificial intelligence has made substantial contributions by means of the agent abstraction and the decentralized mechanisms that govern their behavior and adaptation~\cite{}. Nonetheless, there are significant differences with respect to the specification, design and programming of multi-agents from how software engineers develop pervasive applications~\cite{}. To name just a few, much of nowadays applications are structured around the interaction with its users (e.g., Activities in Android) and follow a model-view-controller architectural pattern. Also, many applications interact only with or through cloud-based servers (vertical interaction). Collaboration among application peers (horizontal interactions) is not common, despite its potential to enable new features and to improve non-functional attributes of pervasive applications.

There ha also been extensive work to enable opportunistic interactions in pervasive computing research community~\cite{}. In many cases, the proposed solutions are narrow with respect to the type of interaction they aim to achieve; in others, the proposed solutions... %TODO: this is a critical point. I have yet to talk about Weyns (SA) and Zambonelli (SO). But before them, there's a vast literature from PC community that cannot be ignored. Why their proposals are not good enough? Because they don't deal with evolution/adaptation?

%must not disrupt, but complement well established software engineering principles and practices. In this sense, a pure agent-oriented approach fail to meet such requirement.  

%there is still a gap, both at the conceptual and concrete levels, of how software engineering community can make use of the relevant solutions from distributed artificial intelligence to the development of pervasive applications. % that exhibit similar requirements for decentralization, context-awareness, and adaptation. 

%This subsection contextualizes the reader about role-orientation in the literature and the novelty of using the role abstraction to build collaborative PA
\subsection{Role-orientation}

%For this, we propose to elevate the concept of a role to a first-class abstraction. 
%A tree with the types of role: symmetric and asymmetric branches with the corresponding types of roles in increasing levels of concreteness 

%What's the difference between tasks and roles?


The concept of roles has been applied in very different areas of information systems, including object-oriented programming, distributed multi-agents, role-based access control, and others~\cite{}. Despite its widespread adoption, there is no common definition for the concept of roles, but actually distinct meanings depending on the context they are employed. Nonetheless, a role is generally associated with rights, responsibilities, and skills.

Regardless of the extensive number of proposals in which the role abstraction is an important aspect or even a key part of the solution, including organization-centered multi-agent systems~\cite{}, not much attention has been paid to the use of role abstraction in the context of pervasive computing, specially when considering the plethora of heterogeneous devices or situations of high volatility. This work aims to fulfill this gap. % by combining role and other organizational abstractions with the state of the art in discentralized self-adaptation and self-organization mechanisms.

%In specific, role-orientation could leverage the potential of context-dependent and opportunistic interactions among pervasive devices.

\subsection{Self-organization and Self-adaptation}

Whereas self-organization and bio-inspired approaches have been a recurrent approach for building decentralized, scalable, and adaptable multi-agent systems, self-adaptation is yet to show its feasibility when subject to volatility and large scale of adaptive entities (e.g., components, agents, etc) and no centralized control. To this end, the gap between bottom-up self-organization and top-down self-adaptation has been a focus of research~\cite{Kramer:, Zambonelli:, Weyns:}. Such a combination may deem beneficial in the context of pervasive computing: in one hand, the volatility and resource limitations characterizing pervasive devices could cope with the scalability achieved by decentralized self-organization mechanisms. In the other hand, a self-adaptation control loop could mitigate undesirable behaviors that may emerge from self-organization and to further improve the capabilities of the system to adapt to varying situations~\cite{Zambonelli:}. In this paper, we propose the combination of both strategies in the formation and adaptation of opportunistic organizations of pervasive entities.

%Thus, the challenge is twofold: to preserve the well known benefits of existing software engineering methodologies, and inherit/adapt the mechanisms from DAI that can cope with the characteristic of pervasive applications.

\subsection{Motivating Scenarios}\label{sec:motivating}

Among the assumptions and characteristics of the scenario tackled by work, the following are considered as key features:

\begin{enumerate}[label=C\arabic*]
	
	\item \textbf{Connectivity:} devices are expected to communicate with each other, while in the same area, through infrastructure Wi-Fi or D2D communication.
	
	\item \textbf{Volatility and Heterogeneity:} application nodes are expected to enter/leave a given zone/network without notice; also, the physical and computational environment in which application nodes operate is subject to changes that may affect capabilities required by the application.
	
	\item \textbf{Intensity:} application nodes may be required to perform resource-intensive tasks or to exchange large volumes of data, or a mix of both.
	
	\item \textbf{Delay-sensitive:} among the application features, some may be sensible to latency.
	
	\item \textbf{Scale:} up to a large number of application nodes are expected to co-exist in a given zone/network and potentially interact.

	
\end{enumerate}

Next, we present examples of applications with use cases that motivate our approach.

%THE WOLRD CONTEXT (PHYSICAL + SOCIAL) --> THE NODE CONTEXT (ROLE) --> THE NODE BEHAVIOR
\begin{figure*}[t!]
	\centering
	\includegraphics[width=0.95\linewidth]{figures/rationale}
	\caption{Role-orientation rationale}
	\label{fig:rationale}
\end{figure*}

\subsubsection{Collaborative Music Streaming}

nowadays, popular services allow users to listen to music streamed from the Internet to their mobile devices. It has also become popular the use of portable speakers equipped with Bluetooth, so that users can enjoy a more powerful audio than provided by their smartphones and tablets. This combination of pervasive devices is specially appealing for external gatherings in parks and other recreational areas. Nowadays, many of these spaces provide public Wi-Fi and/or good cellular network service coverage (\textbf{C1}). However, both the streaming of music from the Internet and the communication through Bluetooth are expensive features in terms of battery and networking, as large volumes of data must be transferred (\textbf{C3}) with minimum delay (\textbf{C4}). Hence, to mitigate the battery drain and, if no Wi-Fi is available, to alleviate the amount of data each device has to download from its data plan, as many as possible devices should  share this responsibility. In other words:

\begin{itemize}
	
	\item a \textit{streaming-role} must be dynamically assigned to one device at a time without interrupting the music play;
	
	\item assignment must happen without manual intervention from users;
	
	\item the time contribution time of each devices must be considered (fairness); and
	
	\item conditions such as the battery level, as well as the Internet and Bluetooth throughputs must be taken into account.
	
\end{itemize}




\subsubsection{Mobile Crowd-sensing}

mobile crowd-sensing (MCS) consists of a paradigm in which the sensors of user-companioned devices are employed in the measurement of urban and social phenomena~\cite{Guo:2015}. Existing MCS applications range from private and public urban transportation monitoring (e.g., Waze\footnote{https://www.waze.com} and Moovit\footnote{https://www.moovitapp.com}) to atmospheric pressure, noise and air pollution measurement (e.g., PressureNet\footnote{http://www.pressurenet.io}, AirPatrol~\footnote{http://www.crowdfunder.co.uk/crowdsource-air-pollution-in-london}). In transportation monitoring applications, geolocation -- fetched from GPS sensors -- is the main data to be collected, while in other cases, geolocation provides geographic contextualization of the data from other sensors. Finally, some MCS applications require additional wearable sensors (e.g., to monitor the quality of air in AirPatrol) that communicates its results through Bluetooth to a main device (e.g., smartphone).

Many MCS applications target a well defined geographic region and period of time. Accordingly, multiple mobile devices running the application may be sharing the same Wi-Fi network or within range of D2D communication (\textbf{C1}). Also, while moving within a campaign area, devices may suffer from fluctuations of the received Wi-Fi/Bluetooth/GPS signals, as well as exhibit distinct levels of battery and sensors of different quality (\textbf{C2}).
%Also, user-companioned devices hosting the application are expected to join/leave the campaign area (\textbf{C2}). 
Whereas some campaigns allow data to be analyzed later, real-time crowd-sensing require a minimum delay between the collection of data and their delivery to backend servers for further processing and publication (\textbf{C3}). Sensors like GPS impose a significant battery drain, and campaigns like transportation monitoring require a frequent activation of this sensor (\textbf{C4}). Finally, with the popularization of crowd-sensing applications, a large number of participants may eventually co-exist in the same campaign area (\textbf{C5}). 

Like other mobile applications, the majority of nowadays MCS are designed following a client-server architecture in which application nodes collect data from their sensors independently from one another. 
%At most, sensing activities in the client applications are coordinated by the backend server, incurring in additional processing by these servers and exchange of data through Internet. 
This common approach has the following drawbacks:


\begin{itemize}
	
	\item \textbf{Coordination}
	
	\begin{enumerate}[label=-]
		
		\item Without coordination, application nodes cannot adapt to situations in which multiple devices can provide the same information, thus they tend to consume unnecessary resources as sensing tasks could otherwise be allocated to a subset of the available devices.
		
		\item With coordination, nodes could agree on which nodes should perform which tasks at each moment, taking both individual and social contexts into account (e.g., churn of devices, variations in the quality of sensors measurements, intermittent connection with servers, low battery level, etc). 
		
	\end{enumerate}
	
	\item \textbf{Collaboration}
	
	\begin{enumerate}[label=-]
		
		\item Without collaboration, each node sends its data to the backend server responsible for filtering and aggregating samples, increasing the the server load and the Internet usage. Additionally, all nodes are assumed to have Internet access to communicate with the server and no collaborative of data is employed (e.g., \cite{Rajagopalan:2006});
		
		\item With collaboration, elected application nodes could aggregate data collected from different sensors (e.g., \cite{Wang:2015}) and average those with higher accuracy. Accordingly, less data would to be transmitted to and processed by backend servers. 
		
	\end{enumerate}
\end{itemize}
