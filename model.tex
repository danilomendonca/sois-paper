\section{The Group-based Model}\label{sec:model}

\subsection{Nodes}

At the basis of the physical model target by this proposal lie the application nodes. Here we consider nodes to be physical devices and not just virtual endpoints; they provide the hosting environment for the execution of logical tasks and they may be equipped with hardware components required by the application. In contrast with other proposals, we consider nodes to be first-class entities whose heterogeneity and volatility must be acknowledged and handled by the system. Moreover, we focus on direct interactions between nodes in order to coordinate the distributed activities and to adapt the system. For this, we assume nodes to have connectivity among each other. Figure~\ref{fig:node_architecture} shows the high level architecture of an node. %At the application layer...

\medskip
\textit{Q: What about devices that run a firmware instead of an OS (Fig.2)?}
\medskip

While physical entities, the context of nodes is formed by -- but not restricted to -- the physical resources available to it at a given moment. Due to many reasons, these resources vary through time, causing context changes. We also consider any further characterization of the nodes in physical world to be a potential context. Table~\ref{tab:resources_types} lists the different resource types.

\begin{table}[t]
	\centering
	\begin{tabularx}{\linewidth}{@{}|c| *1{>{\centering\arraybackslash}X|}@{}}
		\hline 
		\textbf{Context Type} & \textbf{Examples}\\
		\hline
		Computational resources &  CPU, memory, and storage\\ 
		\hline 
		Auxiliary resources & battery, GPS, accelerometer, bluetooth, Wi-Fi, vibration, etc\\ 
		\hline 
		External resources & GPS signal, mobile telephone signal,  etc\\ 
		\hline
		Physical properties & geolocation, altitude, temperature, etc\\
		\hline
	\end{tabularx}
	\caption{Physical resources that form the context of an application node.}
	\label{tab:resources_types}
\end{table}


%Each application node executes an instance of a middleware. This instance provides an interface between the application logic

%managing the life-cycle of groups and roles play


%In this work, we are interested in the direct interaction among devices at the edge of the network. 

% Some activities are purely logical, while others depend on specific hardware components like sensors and actuators. %Moreover, these devices may be equipped with hardware components such as sensors and actuators that are required by the application. 
%This should be placed a the introduction
%Additionally, we target \textit{fog-computing} scenarios in which computational tasks and their coordination happens at the edge of the network. As such, Each node runs an instance of the middleware, which is responsible for the whole life-cycle of groups and there are no dependencies with external services. 

%Thus, we do not rely on any service provided by external components running in the local or in the cloud infrastructure. 

\begin{figure}[t!]
	\centering
	\includegraphics[width=0.5\textwidth]{figures/node_architecture}
	\caption{The architecture of an application node.}
	\label{fig:node_architecture}
\end{figure}

%: the middleware layer exposes features that are consumed by the application layer, including access to the tuple space, mechanisms for managing groups and roles and their adaptation.
%We abstract potential network disconnections of nodes as part of components churn. 

\subsection{Roles}

Roles % represent system behavior; are system modules; 
are units of logic with a clear purpose in the system. Furthermore, roles are expected to interact with each other in order to coordinate their activities and to share information. 
Certain roles are part of the application logic that cannot be decoupled from the nodes -- for instance, those that handle interactions with users. In contrast, other roles can be assigned to a subset of the system nodes. Accordingly, the cardinality of a role with respect to the number of system nodes can vary. 
%and there are cases in which the requirements for the cardinality of a given role does not match the number of nodes.
% -- either because too few or too many nodes are able to assume a that role. 
Table~\ref{tab:role_node_cardinality} summarizes the possible cases.

\begin{table}[t]
	\centering
	\begin{tabularx}{\linewidth}{@{}|c| *1{>{\centering\arraybackslash}X|}@{}}
		\hline 
		\textbf{Role-Node Relation} & \textbf{Description} \\
		\hline
		$1-1$ & All nodes must play a given role \\ 
		\hline 
		$n-p$ & Among $n$ nodes, $p$ nodes must play a given role, with $p < n$ \\ 
		\hline
	\end{tabularx}
	\caption{The cardinality relation between system roles and nodes.}
	\label{tab:role_node_cardinality}
\end{table}

The first case (1-1) refers to the trivial and more evident relationship. For instance, all peers of a mobile game application should perform the roles responsible for collecting user commands and updating the user interface with according to the current game state. In contrast, if the same group of nodes depends on information provided by sensors -- e.g. temperature or geolocation -- not all of them may have to access their sensors simultaneously. 
%Or, if the same group needs to report its position to a remote endpoint, not all of them must send the average geolocation data. 
Behaviors that produce results that can be shared by a given number of nodes and performed by a subset of these same nodes are represented by the second cases in Table~\ref{tab:role_node_cardinality}. The value o $p$ shall be either specified by the application or computed at runtime according to the attributes affected.

%These cases are addressed in the following sections of the paper where groups and self-management mechanisms are discussed.

Conversely to the role-node relation, restrictions may also apply to the number of instances of a given role that a node can play. %While certain roles require an exclusive dedication from the device, others may have more than a single instance running in the same node. 
Table~\ref{tab:node_role_cardinality} describe the possible	 cases. The first (1-1) refers to roles that require an exclusive dedication from the device. The later case (1-k) refers to the general case in which the number of instances is either constrained by the application or left unbounded. The cardinality of roles is further discussed in later sections.


\begin{table}[t]
	\centering
	\begin{tabularx}{\linewidth}{@{}|c| *1{>{\centering\arraybackslash}X|}@{}}
		\hline 
		\textbf{Node-Role Relation} & \textbf{Description} \\
		\hline
		$1-1$ & A node can only play a given role once \\ 
		\hline 
		$1-k$ & A node can play $k$ instances of a given role \\ 
		\hline
	\end{tabularx}
	\caption{The cardinality relation between system nodes and roles.}
	\label{tab:node_role_cardinality}
\end{table}


%In addition, some cyber-physical devices have exclusive and fixed capabilities which allow them to perform specific roles -- usually provided by exclusive hardware components; other devices can perform different tasks and assume multiple roles. 


\subsection{Groups}

%\begin{figure}[t!]
%	\centering
%	\begin{subfigure}[t]{0.5\linewidth}
%		\centering
%		\includegraphics[height=1.2in]{figures/roles_replication.png}
%		\caption{An homogeneous group composed of replicas of the same role.}
%		\label{fig:roles_replication}
%	\end{subfigure}%
%	\begin{subfigure}[t]{0.5\linewidth}
%		\centering
%		\includegraphics[height=1.2in]{figures/roles_distribution.png}
%		\caption{An heterogeneous group composed of different roles.}
%		\label{fig:roles_distribution}
%	\end{subfigure}
%	\caption{Two application groups: one that replicates the same role and another with a mixed configuration}
%\end{figure}

%\begin{figure}[t!]
%	\centering
%	\includegraphics[width=0.5\textwidth]{figures/roles_distribution}
%	\caption{The leftmost device is playing three different roles. The devices in the middle are playing two roles each, while the last rightmost device is playing only one role.}
%	\label{fig:roles_distribution}
%\end{figure}

%Q: What are the properties of a group?

%Stability <- transparency, availability
Given a set of application nodes and roles, there may be different reasons for partitioning the complete set of roles into subsets. Each subset may be assigned to a distinct goal, or different instances of the same goal may have to be achieved by different subsets. As such, a group is defined as an entity to which a collection of nodes can be assigned to play one or more types of roles. 

The criteria for grouping can vary, ranging from static (design-time) to dynamic (runtime) criteria, and from physical (real world) to logical (application) criteria. There are no restrictions for the level of abstraction and granularity of groups and roles; they are let to the application designers to decide. Thus, groups and roles provide flexible building blocks that can be used to organize the application logic.

%In contrast with the A-3 model, groups can be further divided into sub-groups, forming what we call a \textit{group-of-groups}, or hierarchical composition. 

%!
%Groups are useful for partition the system into partially independent modules~\cite{Baresi:2011}. 

At runtime, the first and foremost benefit that emerges from groups is their stability. While nodes are expected to frequently leave the system, a group can outlive churn by reassigning orphan roles to the remaining system nodes and to newcomers (robustness). 
%Such property has two facets.
%as groups existences depend on the very existence of system nodes,
%(as long as they are able to assume those tasks). 
Additionally, as expressed by the asymmetrical cases in Tables~\ref{tab:role_node_cardinality} and \ref{tab:node_role_cardinality}, certain roles are not required to be played by all nodes. Groups can contain homogeneous roles, of which just a part remains active. Standby roles (redundancies) should provide fault-tolerance and improve availability by reducing the time taken to reassign orphan tasks. In the same line, fairness can be achieved by rotating the active roles in a group.
%Therefore, groups tend to be a more stable entity that can outlive components failures and churn.
Figure~\ref{fig:homogeneous_group} illustrates an example of a group formed by GPS components running in different proximal mobile devices.

\begin{figure}[t!]
	\centering
	\includegraphics[width=0.45\textwidth]{figures/homogeneous_group}
	\caption{A GPS group with two active components (blue diamonds) responsible for fetching geolocation. Each component is allocated in a different mobile device. Standby components (gray diamonds) can swiftly assume the task. All components have access to a tuple space, which is kept and managed by a single device.}
	\label{fig:homogeneous_group}
\end{figure}

%Such stability allows components to rely on groups to have the means of coordinating their activities. 
%where activities can take place.%, i.e., one that can cope with the tribulations caused by the volatility of its components. 

%Homogeneous groups can also aggregate data from different components (aggregation). 

%Fairness and other attributes


%The activation of each component is handled by the group. Such decision depends on the application criteria for accuracy, the GPS signal received and the resource utilization at each device. 

%As long as the application requirement for accuracy allows, not all devices must have their GPS component active at the same time.

%TODO This is rather a motivation/problem to be presented at the introduction
%Sensing activities are becoming an essential requirement for many applications. The information collected by sensors can be the target of the system - like in applications for transport and smart cities monitoring - or used to contextualize the application about its surrounding environment. Nonetheless, they tend to be battery consuming activities that must be employed wisely. 

%Group of groups are useful to digest the information from inner groups and to provide a shared tuple space for inter-group communication and coordination.

%Dualism
The stability of groups can be explored in different ways. In addition to the application roles, groups can also serve as containers for the mechanisms responsible for their self-management and adaptation. In specific, we propose the encapsulation of these mechanisms into \textit{management roles} that can be dynamically distributed to the group nodes, enabling the managing system to also benefit from higher robustness and availability.

%Information containers
%In addition to stability and the modularization of the application logic, 
Last but not least, groups can also be containers of system information of different kinds. First, a group must keep an updated register of its members, also called a group view. Moreover, group views can be extended with contextual information from member roles, such as the availability of their resources (Table~\ref{tab:resources_types}). Context information can be useful not only for the application itself, but also for measures of self-adaptation that can cope with context changes. 

In accordance with data-centered solutions that allow time and space decoupling, we use a  \textit{tuple space} solution~\cite{Murphy:2006} for keeping the transient group information. %Different strategies can be used to improve the availability of tuples within a group, e.g., by replicating the data among different devices~\cite{Murphy:2006:2}. 
Tuple access and storage are encapsulated by \textit{tuple manager} roles. This and other management roles are discussed in Section~\ref{sec:group_mangement}.

%Last but not least, groups are equipped with membership control. The later can restrict the access to the group information by checking for the specified requirements for joining the group.

%replication manager
%membership control
%

\subsection{Communication and Coordination}\label{sec:group_cc}

%Q: How to integrate group communication mechanisms with tuples?
% A first option is to assume group communication as a separate mechanism that complements tuple space. As such, nodes could either write to a tuple space or use BMUA.
% A second option is a partial merge of the methods. Meaning, broadcast and anycast are achieved by writting into a tuple space. Multicast and unicast, due to their semantic, are kept the same. I must investiga
 
%Q: How to enable integroup communication?

% Assuming all nodes from the distributed system to be connected, inter-group comm. can happen with any model that keeps track of the members of a group, like event/data-driven or plain group communication provided by middlewares. The advantage of using abstractions such as group-of-groups would be to orient the network infrastructure in terms of resource usage: should a session exist among which devices? 

%TODO
%In contrast with plain group communication mechanisms, we propose the use of a data-centric model within the group. 

%Groups and other models
%Differently from a pure tuple space solution in which any node can subscribe, read, and modify the tuples, we focus in how tuples can be explored within the scope of a group or composition of groups. In fact, both event and data-centric models work with implicit groups: those formed by nodes listening for system events and data modifications. Here, conversely, groups are explicit entities whose particular features and properties - stability, modularity, access control, communication, self-management - are enriched with those of tuple spaces. 

%Group communication
The classical group communication methods are replaced in favor of tuple space operations. Accordingly, a \textit{broadcast} is achieved with a modification in the group tuple space. More granular communication (\textit{multicast}, \textit{unicast}) can be analogously achieved by letting members of a group to listen to modifications of specific tuples. Finally, the \textit{anycast} mechanism can be achieved with the read-and-remove tuple operation. 

%Finally, we consider \textit{unicast} to be a direct way of communication that should keep its original behavior, i.e., to require the presence of the recipient in the group at a given moment. %TODO smart anycast

%Through groups, our proposal follows the principle of avoiding unnecessary disturbances in the system, i.e., to isolate the action to where it makes sense.


%Inter-group communication
While intra-group communication allows members to share data and coordinate their activities, members of different groups may also need to eventually interact. Inter-group communication could be implemented by just letting members to intercept a given network broadcast carrying the name of the destination group. However, as more nodes join the system, it becomes prohibitive to use broadcasts. Groups could also share their view among each other to enable network multicasts addressed to group members. Nonetheless, it would be costly to keep track of all groups and their members (global knowledge), as in volatile environments this would require constant updates of shared group views.

To provide a scalable solution for inter-group interaction, we extended the notion of a group-of-groups composition with that of gateway roles. For this, a group-of-groups composition creates an outer group with similar properties of trivial groups, including a tuple space and its management. The main difference is that the outer group view is composed only by the gateways of its inner groups. These roles are responsible for proxying the operations over the  outer group tuple space, which enables the coordination of different inner group members. Figure~\ref{fig:group_of_groups} illustrates an example of group-of-groups composition. As expected, the tuple manager runs at the same device of one of the gateways - D2 in this example.

%This approach prevents the creation of an overpopulated outer group and enables inter-group communication by allowing members of different inner groups to access and modify a shared tuple space. 

\begin{figure}[t!]
	\centering
	\includegraphics[width=0.48\textwidth]{figures/group_of_groups}
	\caption{A group-of-groups composed of three other groups. Inner groups are populated with different roles; active roles are colored, while standby roles are grayed out. Numbers identify the devices (D1-4) which are hosting each role. Gateways and tuple manager roles are indicated with symbols .}
	\label{fig:group_of_groups}
\end{figure}

%Group communication session
To avoid the time overhead for connection set up, groups can establish network sessions among its members. As such, tuple operations within a group should take place in a more efficient way than in plain data-centric solutions that provide no orientation for the underlying network layer -- i.e., solutions in which tuple access and modifications require fresh connections or, conversely, that eagerly keep open connections among all nodes. Figure~\ref{fig:group_composition_sessions} shows both inner groups and outer group sessions in a group-of-groups composition. We represented the hosting devices instead of roles to enforce the \textit{shared device} criteria for choosing gateways.

\begin{figure}[t!]
	\centering
	\includegraphics[width=0.4\textwidth]{figures/group_composition_sessions}
	\caption{Sessions of different inner groups within a group-of-groups composition (left) and the resulting outer group session between elected gateways in D3 and D6 (right). Communication between gateways in D3 and D6 happens through the network, while the gateways in D6 can communicate internally.}
	\label{fig:group_composition_sessions}
\end{figure}

%TODO see how to cope this idea with shared tuple space
%In addition to intra-group and horizontal inter-group communication, a group-of-groups also provide vertical communication. This style enables any inner group member to provoke the outer group with tuple modifications, which are echoed to all inner groups members (group-of-groups broadcast). The advantage here is to constrain such perturbations of the system to the boundaries of the outer group.

\section{Self-Management}\label{sec:group_mangement}

%In this work, we are interested in the scenarios in which roles within a group are played by different physical devices. 


The group-role model allows the system architecture to evolve and to cope with volatile and unpredictable environments. Given a disposition of groups and roles, the entrance and exit of nodes and the variation in the context of each node can cause the disruption of normal system behavior and the violation of application requirements. In this work, we aim at architectural adaptations of the following types:

\begin{itemize}
	\item The creation and destruction of groups;
	
	\item The creation and destruction of roles;
	
	\item The activation and deactivation of roles;
\end{itemize}



%There are different aspects of a group life-cycle that must be autonomously managed.   

%Autonomous systems should be able to observe their context of operation and to cope with changes. As part of the framework, we propose a set of \textit{managing roles} responsible for monitoring, analyzing, planing, and executing adaptive actions. In specific, we target attributes that are inherently affected by the group-role structure, including the distribution of roles to different nodes and the cardinality of roles in each group. 

\subsection{Activation Management}

It consists of controlling the components within a group that are active and those that are in standby mode. This mechanism targets situations in which there are more components able to perform a given system role than it is required by the application: in case a high availability is a requirement, a \textit{to group and standby} provides a low latency replacement of orphan roles; in case the role is resource demanding, activation management can also rotate active components among different devices (fair load distribution). 
%\textit{Q: The middleware is also a software. By providing this type of self-management feature, I should give clear details about its realization - is it distributed among group members? is it based on the local group knowledge only? }


%The \textit{to group and standby} enables proactive fault-tolerance, in which a part of the components in a group are in standby (not active). Standby components should be activated to avoid violations of the system requirements, which can be directly expressed in terms of cardinality per group or by attributes mapped to the cardinality. In contrast, the \textit{to group and replace} (reactive fault-tolerance) depends on how long the task provided by the component can remain interrupted (availability requirement). Although passive components are not actually performing any tasks, they are supposed to maintain the conditions to become active when needed, which translates into having the required resources available (readiness). Thus, standby components also have a cost. 

%The mechanism that manages component activation within a group must 

The autonomous activation management of a group requires the classification of its components by the following criteria:

\begin{itemize}

\item their readiness to become active (needed resources), represented by $R$;

\item their membership expectancy (stability), represented by $ME$; 

\item their service time in the group (fairness), represented by $ST$;

\end{itemize}

The activation score (AS) of a component is calculated as follows:

\begin{equation}
AS = R * (ME * \alpha - ST * \beta)
\end{equation}\label{eq:activation_score}

With $R$ ranging from $0$ to $1$ according to the conditions required for a role to be played; $ME$ ranging from $0$ to $1$ according to the time a node component is expected to remain in the group; and $ST$ ranging from $0$ to $1$ according to the time a node has been active in the group; $\alpha$ and $\beta$ are compensation constants that can respectively increase or reduce the importance of $ME$ and $ST$ variables in Eq.~\ref{eq:activation_score}. The resulting \textit{activation order} of group components must be updated with some periodicity to reflect context changes. Figure~\ref{fig:role_states} shows the different states of system roles.

\begin{figure}[t!]
	\centering
	\includegraphics[width=0.8\linewidth]{figures/role_states}
	\caption{Role states: the \textit{inactive} state represents roles that have not joined a group; the \textit{standby} state represents dormant roles within a group; the \textit{active} state represents roles that are engaged in their system tasks.}
	\label{fig:role_states}
\end{figure}

\subsection{Tuple Management}

%Tuple management
Tuple spaces solutions aiming static or less dynamic environment must be adapted to work in the highly volatile scenario target by this proposal. First, tuples must have a certain degree of replication among group members. We tackle this with the same mechanism for managing the active roles in a group. The particularity here is that standby tuple mangers should keep consistent copies of the tuple space.

Like in homogeneous groups, the selection of active tuple managers must respect the contexts of devices, including their current usage of resources and their expectancy to remain in the system. Also, despite tuple managers and gateways to be different roles, sharing the same host eliminates the communication overhead. Accordingly, we propose a combined election of both roles.

%Composition
%Regarding membership, groups can receive qualitative and quantitative specifications for the components they accept. In our work, a component type is defined as a role. In contrast with previous works~\cite{A3}, we do not restrict a group to homogeneous roles. Accordingly, groups can accept a single or multiple roles and impose or not limitations to their cardinality.

%Self-grouping
%Groups can also be specified with quality-of-service (QoS) attributes. These should become criteria for the self-organization of a group with respect to its composition. For example, the performance, the availability, the reliability, and other attributes can be estimated based on the components in a group. As such, a group can act to avoid violations of these attributes by changing its composition, including the simple activation and deactivation of standby components and negotiating with other groups for reallocating its members.

TODO: define a common adaptation model and apply this model to the multiple cases, including intra-group adaptation and inter-group adaptation.

\subsection{Extension Points}

%Application specific attributes
Apart from more evident attributes that can benefit from a group formation -- like reliability and availability -- application specific attributes may also depend on %properties such as 
the number of roles active in a group. For instance, the performance of a parallelized activity is affected by the number of participants; or the accuracy of the data collected by sensors may improve with additional samples from different sources. To address these cases, we propose a specification language that allows the application requirements to be specified. In addition, we specify extension points to allow customized mappings between a given attribute and the group-role organization. The combination of both should be used by the autonomous mechanisms for adapting the system and avoid requirements violations.

%\input{self_grouping}