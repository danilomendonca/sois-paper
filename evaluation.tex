%%!TEX root = main.tex
%% -*- root: main.tex -*-
%\section{Middleware}\label{sec:middleware}
%
%\subsection{SOIS with Existing Coordination Models} 
%
%\subsection{Interoperation} 
%
%\subsection{Discovery and Contextualization} 
%
%The application nodes sharing the same interaction space must become aware of each other. In the more trivial cases, social awareness is part of the application requirements (e.g., in a chatting or in a multiplayer game application); or, the social context affects the way the application can achieve its requirements. The later may refer to the cases in which functionalities are provided by specialized nodes (e.g., by sensors, actuators, gadgets, and other devices composing the application). It may also refer to situations in which the quantity and quality of nodes defines a social context to which the application must adapt to (e.g., if too many sensors are available, a subset can be chosen to spare the other's resources).
%
%%Whereas the discovery of ambient and web services are important and have been addressed by many works~\cite{Zhu:2005, Meshkova:2008}, 
%
%%hosted by devices able to provide multiple functionalities, i.e., that can assume different roles in application organization. 
%
%To better suit the characteristics in Section~\ref{sec:characterization}, the discovery mechanism should not be centralized by remote components; instead, to avoid latency and Internet dependency, discovery must be carried out and managed from inside, i.e, by the application nodes themselves. To this end, discovery can still rely on some degree of centralization (discovery-nodes) or be completely distributed. The decision of which approach to use must cope with the volatility and large scale characteristics discussed in Section~\ref{sec:characterization}. 
%
%%Popular platforms such as Android NDS~\cite{ANDROID_NSD} and Apple Bonjour~\cite{APPLE_BONJOUR} provide native mechanisms that allow nodes to advertise and discover their services and resources. Additionally, third party frameworks provide multi-platform discovery~\cite{Alljoyn, IoTivity}. We later discuss how this mechanisms could be enriched to suit the type of application described in Section~\ref{sec:characterization}.
%
%
%
%
%
%%TODO explain the gap (if any) or which discovery mechanism should be used
%
%%Following the taxonomy in~\cite{}, 
%
%%\subsubsection{Interoperability}
%
%%In a blackbox architecture (e.g., service-oriented and resource-oriented architectures), endpoints providing a service or resource encapsulate their inner components and logic and expose their functionalities through remotely accessible interfaces. This type of architecture suits well the cases in which different platforms and applications need to interoperate by means of request-response between clients and agnostic services. However, the overhead and limitations they impose may not be justified in the case of interactions among nodes of the same application. Thus, a component-based architectural style provides the loose-coupling and flexibility required by the volatility of mobile devices. 
%
%%Different paradigms and architectural models for distributed systems provide their own discovery technology and specification. The discovey mechanisms in these models is either an industrial standard (e.g., the service registry in SOA~\footnote{http://uddi.xml.org/}) or are currently been investigated (e.g., the P-REST extension to REST~\cite{Caporuscio:2015}). 
%
%%TODO refactore this paragraph and continue this ssection
%%In specific, components are independent, loose-coupled entities that can be added/removed from the system at runtime. Therefore, mobile devices can host components that, once in the network, advertise their presence and become aware by its peers.
%
%%%Content and control can be broadcasted;  
%
%%%In mobile crowdsensing, the discovery of peer nodes is particularly important as each node is a potential contributor to the existing campaigns. 
%
%%TALK ABOUT THE DCVRY METHODS AND THEIR SUITABILITY TO THE SCENARIO AND REQUIREMENTS PRESENTED BY THIS WORK.
%
%%Whereas previous coordinating models for mobile computing assumed the worse case for connectivity (nodes eventually meet and exchange data)~\cite{LIME, TUCSON, OTHERS}, nowadays wireless technologies makes it possible for multiple application nodes to be interconnected at the same time. Given the resource limitations of mobile devices, discovery mechanisms must avoid creating too much computational overhead or flood the network with discovery messages. As the peer scale grows, such requirements becomes critic for the feasibility of an edge space for interactive applications. 
%
%\subsection{Underlying Framework}
%
%While the choice of a specific framework is orthogonal to the main concepts and the self-organization mechanisms presented by this work, we considered the arguments for a resource-oriented architecture~\cite{PRIME} and adopted IoTivity as the underlying framework on top of which the abstractions and mechanisms of self-organizing edge spaces are built and operate.

\section{Evaluation and Discussion}\label{sec:evaluation}


%The approach was evaluated with an opportunistic mobile crowd-sensing application. In specific, we simulated a public transport monitoring application to compare the efficiency of a pure client-server architecture with a solution based on SOIS.

The simulation experiments aimed at measuring the overhead of the self-organization mechanisms, namely self-grouping and distributed role allocation. As these methods add no significant overhead in terms of processing or memory, the evaluation has focused in the communication overhead, as the exchange of messages through wireless mediums consumes battery from devices and is subject to delays that may interfere with the application behavior. In specific, this metric was evaluated with:

\begin{enumerate}[label=\Alph*]
	
	\item The asymptotic overhead, given by worse case number of exchanged messages required by each self-organization mechanism, as a function of the number of application nodes, groups and roles (Section~\ref{fig:asymmetry}). 
	
	\item The measured overhead, given by the number of exchanged messages counted during simulated executions of a MCS application for public bus monitoring, in which the number of group/roles is fixed and the number of nodes, as well as their capabilities, varies according to probabilistic distributions.
	
\end{enumerate}


\subsection{Asymptotic Analysis} 

\subsubsection{\textbf{Self-grouping}} We analyze the complexity of the grouping method by means of the communication overhead, i.e., the number of messages exchanged between nodes and their payload size. The analysis is divided in two parts: a) the overhead when a node joins/leaves a group (registry update); b) the additional overhead when a node joins a group (registry copy).

In the worse case scenario, registry update (a) takes $n-1$ unicast messages, ($O(n)$), with $n$ the group size, and a single registry line as payload. However, if a broadcast communication is used, a single broadcast message can advertise the registry update ($O(1)$).
%This is the case, e.g., of an UDP broadcast over the 802.11 network protocol (Wi-Fi). 
The registry copy (b), in its turn, requires a single unicast message to be transmitted each time a node joins a group. In contrast with the previous type of message, the registry copy includes information about all $n-1$ nodes in the group. Thus, the total overhead is given by $O(p)$.

\subsubsection{\textbf{Discentralized Role Allocation}} 

%TODO: check the definition of FS and use it accross the paper

The distributed role election involves the exchange of fitness scores among eligible nodes in the advent of the events depicted in the previous subsection. As each node receives the FS from the other nodes, this value is added to the classification list in polynomial time. The number of exchanged messages depend on the network topology and the event that triggers the election. 

In the worse case, represented by an election of a vacant position and no broadcast, each node $e$ in the set of eligible nodes $E$ must send each other an unicast message. If $|E| = n$, the asymptotic message count is given by $O(n * (n-1)) = O(n^2)$. If the nodes in $E$ can communicate through broadcast, this number is reduced to $O(n)$. In its turn, the challenge event produces smaller overhead as the exchange of messages is restricted to a request-response between challenger and challenged and to the subsequent advertisement of the result ($O(n)$ without broadcast, otherwise $(O(1))$).

Once the communication overhead of a single election protocol is known, the overall overhead can be estimated by the number of groups and roles in the application and the frequency of events triggering new elections. Whereas the vacancy and resignation events should be handled by a new election, the frequency in which a challenge event happens depend on the choice for $\delta$: the higher this factor is, the lower the probability of a challenge (and the need for the elected nodes to update their peers about changes in their $FS$). Therefore, the decision of which $\delta$ to be used depends on the criticality or the importance of the attributes that compose the fitness score of a node. 

%two aspects: to show the gain in efficiency of the crowd-sensing campaign based on our framework when compared with a client-server approach; and to show the scalability and performance of the mechanisms proposed, as they impose a communication overhead. 

\subsection{Simulations}

\subsubsection{Experiments Design}

%Distributed role allocation

%-> Each node must calculate and advertise its fitness value for the roles with vacant positions: protocol to calculate; protocol to advertise;
%-> Each node must compare its fitness value with the other nodes and update the assignment for existing positions and assume/resign to a position if another node has a higher value
%-> 

The scalability and performance of the self-organization mechanisms were evaluated using a simulator for P2P  \textit{PeerSim}, an open source peer-to-peer simulator~\cite{p2p09-peersim}. This tool supports the creations of different network topologies and.... 

%To simulate a public bus monitoring crowd-sensing application, experiments were performed with an increasing number of nodes. Each role can potentially play a \textit{gps-monitor}, a \textit{acceleration-monitor}, or an \textit{aggregator} role. Each role has been implemented as a protocol extending the \textit{CDProtocol} class. At each simulation cycle, 
%
%the application roles of a \textit{gps-monitor} and \textit{acceleration-monitor} were implemented as protocols, which are called at each simulation cycle. 
%
%The simulation was executed in a computer with .... 

\subsection{Results}

\subsection{Discussion}