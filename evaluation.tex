%!TEX root = main.tex
% -*- root: main.tex -*-
\section{Evaluation and Discussion}
\label{sec:evaluation}

%target -> 1.5 pages

Herein we evaluate A3Droid's ability to provide robust and scalable crowdsensing. The evaluations were performed as a series of lab experiments that were run on a range of real Android smartphones. These experiments mimic the collection of up-to-date information about public transport by using crowdsensing on moving buses. The app that we built supports both temporal and spatial redundancy when collecting data, can cope with sudden supervisor departures thanks to its use of A3Droid's SFR feature, and can scale as the number of devices on the bus increases. 

In our experiments we have one A-3 group per bus, and each group's supervisor is dynamically selected amongst the people using the app on the bus. Each data reading contains the bus' \texttt{position} (i.e., its \texttt{latitude} and \texttt{longitude}), its \texttt{speed}, its \texttt{direction}, and its \texttt{accuracy} value. Accuracy is defined by Android as the radius of $68$\% confidence. This means that if we draw a circle of radius \texttt{accuracy}, centered at the location's \texttt{latitude} and \texttt{longitude}, there is a $68$\% probability that the true location is inside the circle. The data that are collected are sent by the supervisor to a remote server, which processes these fields and provides up-to-date information about the city's traffic conditions through an appropriate querying REST API. 

%along three main directions. The first is its capability to enable robust crowd-sensing; in particular, it needs to make it easy for developers to cope with a group's supervisor leaving the app. The second is its capability to scale as the number of devices increases; in particular, it needs to be able to support efficient messaging amongst the devices. The third is its capability to enable the collection of high-quality data; in particular, it needs to make it easy for developers to support temporal, spatial, and dimensional redundancy. 

Listing~\ref{lst:LOC_AVG} shows how temporal and spatial redundancy were setup in the supervisor. Method \texttt{run} starts by instantiating a synchronized list for storing the geo-located data that it will receive from its followers. It then proceeds to create a timer that will periodically (i.e., every $30$ seconds) i) calculate the average of the stored geo-located data, ii) send the average to the application's remote server, and iii) cleanse the list. Method \texttt{messageFromFollower} listens for updates from the supervisor's followers. If it receives geo-located data that has an accuracy that is less than a given threshold, the data is added to the list; if not it is discarded.

\lstinputlisting[float=h, caption={Averaging the geo-located data collected by the supervisor.}, label=lst:LOC_AVG]{locationAverage.java}

Listing~\ref{lst:FITNESS}, on the other hand, shows how we exploited A3Droid's SFR feature to trigger a new supervisor election every time the supervisor's absence was detected. We created a fitness function that took into account the number of bus stops that separate the passenger from his/her final destination. To minimize the number of supervisor elections, we always selected the device of the person with the longest trip ahead of them. 

\lstinputlisting[float=h, caption={The fitness function used to elect the bus' group supervisor.}, label=lst:FITNESS]{fitnessFunction.java}

In our experiments we stressed the middleware with a high number of messages, increasing the size of the group from $3$ devices up to $12$ (i.e., a realistic amount of devices for our scenario). To simulate users getting on and off the bus, a second round of measurements was performed, in which we repeatedly added and removed two devices at a time. The measurements took $5$ minutes each. A uniform distribution between $0$ and $10$ seconds was used to distance consecutive messages being sent by the same follower. In the real-world this interval would vary according to the speed of the bus, as well as other factors.

\begin{figure}[ht]
\centering
\begin{tikzpicture}
	
			\begin{axis}[
%				group style={
%					group size=2 by 1,
%					horizontal sep=1.5cm,
%				}, %height=3cm,width=3cm,
				xmin=4, ymin=0.3, xmax=12,
				ylabel={	Average RTT (s)},
				xlabel={Number of members in the groups},
				xtick=data,
%				minor ytick=data,
				scale only axis,
				log ticks with fixed point,
				grid=both,
				footnotesize,
%				legend columns=3,
				x post scale=1,
				legend style={at={(0.5,-0.3)},anchor=north},
				cycle list name ={my chart colors}
				]

%				\nextgroupplot
				\addplot+[smooth] table[x=root, y=1] {results/MOBEE_RTTvsGS.dat};
				\addlegendentry[align=center]{Average RTT without churn %\\
				%No churn; 6mes/min; 1kb
				}
				\addplot+[smooth] table[x=root, y=2] {results/MOBEE_RTTvsGS.dat};
				\addlegendentry[align=center]{Average RTT with 2 devices churn %\\
				%Churn of 2 devices; 6mes/min; 1kb
				}
%				\addplot+[smooth] table[x=root, y=1] {results/GH_SS_RTTvsGS.dat};
%				\addlegendentry{Average RRT of sensors to server message [6mes/min, 32b]}			
%				\addplot+[smooth] table[x=root, y=2] {results/GH_SS_RTTvsGS.dat};
%				\addlegendentry{Average RRT of sensors to server message [6mes/min, 1kb]}			
%				\addplot+[smooth] table[x=root, y=1] {results/GH_SA_RTTvsGS.dat};
%				\addlegendentry{Average RTT of a server to actuators message [2mes/min, 64b]}	
%				\addplot+[smooth] table[x=root, y=2] {results/GH_SA_RTTvsGS.dat};
%				\addlegendentry{Average RTT of a server to actuators message [6mes/min, 1kb]}	
			\end{axis}
			
\end{tikzpicture}	
\caption{Messaging performance in A3Droid, with and without churn.}
\label{fig:MOBEE_RTT_VS_GROUP_SIZE}
\end{figure}

The results in Figure~\ref{fig:MOBEE_RTT_VS_GROUP_SIZE} show that A3Droid was able to deliver messages within an acceptable time. The complete round-trip time (RTT) did not go beyond $0.65$ seconds. Confirmation messages were used to achieve more precise measurements --since followers and supervisors do not have synchronized clocks. Single messages would have had a slightly smaller average.

Regarding the framework's ability to scale, the ``no churn'' curve sees a substantial slope increase after $6$ members. This is the point in which the supervisor starts accumulating messages in its queue. This was due to the fact that we used a uniform distribution with a maximum interval of $10$ seconds, leading some messages to be sent within a very short amount time. The ``with churn'' curve starts with a different growth pattern. The constant churn stresses the supervisor, causing an additional overhead of around $0.2$s --seen between the initial points of the two curves. As we can see, the higher the group size the less significant the churn becomes. After $8$ devices the curve inverts its second order growth, and starts following a pattern that is similar to the one seen in the ``no churn'' curve.





%\begin{figure}[!ht]
%\centering
%\includegraphics[width=1\linewidth]{figures/mobee.png}
%\caption{Public transport information sharing system overview}
%\label{fig:MOBEE_OVERVIEW}
%\end{figure}







 



